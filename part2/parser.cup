/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;


/**
 *  Usercode Components
 */

action code {:
	int FnCflag=0;
	int CompoundFlag = 0;
:}

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, LPAREN, RPAREN, LBRAC, RBRAC, COMMA, QUOT, IF, ELSE, PREFIX, SUFFIX;
terminal String     STRING_LITERAL, QSTR;        // our scanner provides numbers as strings


/*  Non terminals */
non terminal            Goal, Start, Function, FunctionD,FDecl, FCall, CompoundStmt, CompoundStmtD, IFEXPR, IFEXPR2, EXPR;
non terminal String    FunctionC, FunctionC2, Declaration, DeclarationD, DeclarationC, Concatenation, ConcatenationD, StringContent, Temp;      // used to store evaluated subexpressions




/**
 *  Precedence Declarations
 */

precedence left PREFIX, SUFFIX;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left IF, ELSE;

/**
 *  The Grammar Rules
 */

/* kanonas gia func Decl kai meta kanonas gia func calls , opote otan einai gia func calls sthn arxh ftiaxnw thn main */

/* take all inputs such as : first function declarations and after function calls or vice versa */

/* xreaizetai kai ena Goal ::= Start; gia na ftiaxoyme thn Main class */

Goal	::=	Start:s 					{:System.out.println("public class Main {\n\t" + s + "\n}");:}
		;

Start ::=	FunctionD:s1 FunctionC:s2			{:System.out.println("PER 1");  RESULT = "\n\tpublic static void main(String[] args){\n\t" + s2 + "\t}\n\n\t" + s1; :}
		|	FunctionC FunctionD					{:System.out.println("PER 2");:}
		|	FunctionD							{:System.out.println("PER 3");:}
		|	FunctionC:s							{:System.out.println("PER 4"+ s);:}
		;		



FunctionD	::=	FunctionD:s1 STRING_LITERAL:s2 LPAREN RPAREN CompoundStmt:s3 									{: if (FnCflag == 0) RESULT = s1 + "public static String " + s2 + "()" + s3 + "\n\t";
																													else throw new Error("Error!"); :}
			|	FunctionD:s1 STRING_LITERAL:s2 LPAREN DeclarationD:s3 RPAREN CompoundStmtD:s4					{: if (FnCflag == 0) RESULT = s1 + "public static String " + s2 + "(" + s3 + ")" + s4 ;
																													else throw new Error("Error!"); :}
			|	STRING_LITERAL:s1 LPAREN RPAREN CompoundStmt:s2 												{: if (FnCflag == 0) RESULT = "public static String " + s1 + "()" + s2 + "\n\t" ;
																													else throw new Error("Error!");  :}
			|	STRING_LITERAL:s1 LPAREN DeclarationD:s2 RPAREN CompoundStmtD:s3 								{:  if (FnCflag == 0) RESULT = "public static String " + s1 + "(" + s2 + ")" + s3 + "\n\t";
																													else throw new Error("Error!"); :}
			; 

FunctionC	::=	FunctionC:s1 STRING_LITERAL:s2 LPAREN RPAREN									{:  RESULT = s1 + "\t\tSystem.out.println(" + s2 +"());\n"; :}
			|	FunctionC:s1 STRING_LITERAL:s2 LPAREN DeclarationD:s3 RPAREN 					{:  RESULT = s1 + "\t\tSystem.out.println(" + s2 +"(" + s3 + "));\n";:}
			|	STRING_LITERAL:s LPAREN RPAREN 													{:  RESULT = "\tSystem.out.println(" + s + "());\n"; :}
			|	STRING_LITERAL:s1 LPAREN DeclarationD:s2 RPAREN 								{:  System.out.println("flag is "+FnCflag +""+s);RESULT = "\tSystem.out.println(" + s1 + "(" 																							+ s2 + "));"  ; :}
			;

/* helper rule, used for nested function calls as arguments */
FunctionC2	::=	FunctionC2:s1 STRING_LITERAL:s2 LPAREN RPAREN									{:  RESULT = s1 + "(" + s2 + ")"; :}
			|	FunctionC2:s1 STRING_LITERAL:s2 LPAREN Declaration:s3 RPAREN 					{:  RESULT = s1 +  s2 + "(" + s3 + ")";:}
			|	STRING_LITERAL:s LPAREN RPAREN 													{:  RESULT = s + "()"; :}
			|	STRING_LITERAL:s1 LPAREN Declaration:s2 RPAREN 								{:  System.out.println("flag is "+FnCflag +""+s);RESULT = s1 + "(" + s2 + ")"  ; :}
			;


CompoundStmt	::=	LBRAC QSTR:s RBRAC 					{: CompoundFlag = 1; System.out.println("HERE "+ s); RESULT = "{\n\t\treturn \"" + s + "\";\n\t}"; :}  
				|	LBRAC IFEXPR2 RBRAC  
    			;

CompoundStmtD	::=	LBRAC ConcatenationD:s RBRAC 					{: CompoundFlag = 1; System.out.println("HERE# "+ s); RESULT = "{\n\t\treturn " + s + ";\n\t}"; :}   
				|	LBRAC IFEXPR2 RBRAC  
    			;

IFEXPR			::=	
				    LPAREN QSTR:s1 PREFIX EXPR:s2 RPAREN EXPR ELSE EXPR
				|	LPAREN STRING_LITERAL:s1 PREFIX EXPR:s2 RPAREN  EXPR ELSE EXPR
				|   LPAREN QSTR:s1 SUFFIX EXPR:s2 RPAREN EXPR ELSE EXPR
				|	LPAREN STRING_LITERAL:s1 SUFFIX EXPR:s2 RPAREN  EXPR ELSE EXPR
				|	LPAREN IFEXPR2 PREFIX EXPR:s2 RPAREN EXPR ELSE EXPR
				|	LPAREN IFEXPR2 SUFFIX EXPR:s2 RPAREN EXPR ELSE EXPR
				;

IFEXPR2 		::= IF IFEXPR
				;

EXPR 			::=	ConcatenationD
				|	IFEXPR2
				; 

/* helper rule, used for nested functions as arguments */
Declaration 	::=	Declaration:s1 COMMA STRING_LITERAL:s2 				{: 
																				 RESULT = s1 + ", String " + s2; :}
				|	Declaration:s1 COMMA Concatenation:s2 					{: RESULT = s1 + "," + s2;:}
				|	STRING_LITERAL:s 										{: 
																					RESULT = "String " + s;  :}
				|	Concatenation:s 										{: FnCflag = 1; 
																					{System.out.println("EDW "+s);RESULT = s;System.out.println(s);} :}
				|	Declaration:s1 COMMA FunctionC2:s2 					{: RESULT = s1 + "," + s2; :}
				|	FunctionC2:s				/*function call as argument */  {: RESULT = s; :}
				;						

DeclarationD 	::= DeclarationD:s1 COMMA STRING_LITERAL:s2 				{: 
																				 RESULT = s1 + ", String " + s2; :}
				|	DeclarationD:s1 COMMA Concatenation:s2 					{: RESULT = s1 + "," + s2;:}
				|	DeclarationD:s1 COMMA IFEXPR2:s2						{: FnCflag = 1; :}
				|	STRING_LITERAL:s 										{: 
																					RESULT = "String " + s;  :}
				|	Concatenation:s 										{: FnCflag = 1; 
																					{System.out.println("EDW "+s);RESULT = s;System.out.println(s);} :}
				|	DeclarationD:s1 COMMA FunctionC2:s2 					{: FnCflag = 1; RESULT = s1 + "," + s2; :}
				|	FunctionC2:s				/*function call as argument */  {: FnCflag = 1; RESULT = s; :}
				|	IFEXPR2 												{: FnCflag = 1; :}
				;						


DeclarationC 	::= DeclarationC:s1 COMMA STRING_LITERAL:s2  				{: RESULT =  s1 + "," + s2 ;:}
				|	DeclarationC:s1 COMMA Concatenation:s2 					{: RESULT =  s1 + "," + s2 ;:}
				|	Concatenation:s 										{: RESULT = s; :}
				;

Concatenation	::=	QSTR:s 										{: System.out.println("ALA"+s+" flag "+FnCflag); RESULT = "\"" + s + "\""; System.out.println(RESULT);:}
				; 

ConcatenationD	::=	ConcatenationD:s1 PLUS STRING_LITERAL:s2	{: RESULT = s1 + " + " + s2; :}
				|	QSTR:s 					{: System.out.println("ALA"); RESULT = "\"" + s + "\""; :}
				|	STRING_LITERAL:s 							{: RESULT = s; :}
				;

StringContent 	::=	StringContent:s1 STRING_LITERAL:s2 			{: RESULT = s1 + " " + s2; :}
				|	STRING_LITERAL:s 							{: System.out.println("EINAI "+s + ".");RESULT = s; :}
				;
