/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;


/**
 *  Usercode Components
 */

action code {:
	int FnCflag=0;
	int Callflag = 1;
:}

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, LPAREN, RPAREN, LBRAC, RBRAC, COMMA, QUOT, IF, ELSE, PREFIX, SUFFIX;
terminal String     STRING_LITERAL, QSTR;        // our scanner provides numbers as strings


/*  Non terminals */
/*
non terminal            Goal, Start, Function, FunctionC, FunctionD , CompoundStmtD, EXPR, FunctionDecl, FunctionCall ;
non terminal String    ArgListOpt, CallListOpt, CompoundStmt,FunctionC2, Declaration, DeclarationD, DeclarationC, Concatenation, ConcatenationD, StringContent, IFEXPR, IFEXPR2;   */   // used to store evaluated subexpressions

non terminal            Goal, Start, FunctionD, FunctionC, FunctionDecl, CompoundStmt1, CompoundStmt2, ArgList, StmtList1, StmtList2, EXPR ;
non terminal String    	ID, Arg, Stmt, FunctionCall, IFEXPR; 


/**
 *  Precedence Declarations
 */

precedence left PREFIX, SUFFIX, LBRAC;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left IF, ELSE;

/**
 *  The Grammar Rules
 */

/* kanonas gia func Decl kai meta kanonas gia func calls , opote otan einai gia func calls sthn arxh ftiaxnw thn main */

/* take all inputs such as : first function declarations and after function calls or vice versa */

/* xreaizetai kai ena Goal ::= Start; gia na ftiaxoyme thn Main class */

Goal	::=	FunctionD:s1 FunctionC:s2					{:System.out.println("public class Main {\n\tpublic static void main(String[] args) {\n\t" + s2 + "\n\t}\n\n" + s1 + "\n}");:}
		;

Start ::=	FunctionDecl:s1 FunctionCall:s2				{:System.out.println("PER 1");  RESULT = "\n\tpublic static void main(String[] args){\n\t\t" + s2 + "}\n\n\t" + s1; :}
		;		

FunctionD 		::=	FunctionD:s1 FunctionDecl:s2  								{: RESULT = s1 + "\n" + s2; :}
				|	FunctionDecl:s 												{: RESULT = s; :}
				;

FunctionC 		::=	FunctionC:s1 FunctionCall:s2  								{: RESULT = "\t" + s1 + "\n" + "\t\tSystem.out.println(" + s2 + ");"; :}
				|	FunctionCall:s 												{: RESULT = "System.out.println(" + s + ")" + ";"; :}
				;

FunctionDecl	::= ID:s1 LPAREN RPAREN CompoundStmt1:s2 						{: RESULT = "\tpublic static String " + s1 + "() " + s2; :}
				|	ID:s1 LPAREN ArgList:s2 RPAREN CompoundStmt2:s3 			{: RESULT = "\tpublic static String " + s1 + "(" + s2 + ") " + s3; :}
				;

FunctionCall	::=	ID:s LPAREN RPAREN 											{: RESULT = s + "()" ; :}
				|	ID:s1 LPAREN EXPR:s2 RPAREN 								{: RESULT = s1 + "(" + s2 + ")" ; :}
				;

ArgList 		::=	ID:s1 COMMA ArgList:s2 										{: RESULT = "String " + s1 + "," + s2; :}
				|	ID:s 														{: RESULT = "String " + s; :}
				;

EXPR 			::=	QSTR:s1 COMMA EXPR:s2 										{: RESULT = "\"" + s1 + "\"," + s2; :}
				|	IFEXPR:s1 COMMA EXPR:s2 									{: RESULT = s1 + "," + s2; :}
				|	FunctionCall:s1 COMMA EXPR:s2 								{: RESULT = s1 + "," + s2; :}
				|	FunctionCall:s 												{: RESULT = s; :}
				|	IFEXPR:s 													{: RESULT = s; :}
				|	QSTR:s 														{: RESULT = "\"" + s + "\""; :}
				;

CompoundStmt1 	::= LBRAC StmtList1:s RBRAC 				{: RESULT = "{\n\t\treturn " + s + ";\n\t}\n"; :}
				;

CompoundStmt2 	::= LBRAC StmtList2:s RBRAC					{: RESULT = "{\n\t\treturn " + s + ";\n\t}\n"; :}
				;


StmtList1		::=	StmtList1:s1 PLUS QSTR:s2 				{: RESULT = s1 + "+ \"" + s2 + "\""; :}
				|	IFEXPR:s1 PLUS QSTR:s2 					{: RESULT = s1 + "+ \"" + s2 + "\""; :}
				|	IFEXPR:s 								{: RESULT = s; :}
				|	QSTR:s 									{: RESULT = "\"" + s + "\""; :}
				;

StmtList2 		::=	StmtList2:s1 PLUS ID:s2 				{: RESULT = s1 + "+" + s2; :}
				|	StmtList2:s1 PLUS QSTR:s2 				{: RESULT = s1 + "+ \"" + s2 + "\""; :}
				|	StmtList2:s1 PLUS IFEXPR:s2 			{: RESULT = s1 + "+" + s2; :}
				|	IFEXPR:s 								{: RESULT = s; :}
				|	ID:s 									{: RESULT = s; :}
				|	QSTR:s 									{: RESULT = "\"" + s + "\""; :}
				;

Stmt 			::=	ID:s1 PLUS Stmt:s2 						{: RESULT = s1 + "+" + s2; :}
				| 	QSTR:s1 PLUS Stmt:s2 					{: RESULT = "\"" + s1 + "+" + s2; :}
				|	IFEXPR:s 								{: RESULT = s; :}
				|	FunctionCall:s 							{: RESULT = s; :}
				|	QSTR:s 									{: RESULT = "\"" + s + "\""; :}
				|	ID:s 									{: RESULT = s; :}
				;

IFEXPR 			::=	IF LPAREN Stmt:s1 PREFIX Stmt:s2 RPAREN Stmt:s3 ELSE Stmt:s4 			{: RESULT = s2 + ".startsWith(" + s1 + ")?" + s3 + ":" + s4; :}
				|	IF LPAREN Stmt:s1 SUFFIX Stmt:s2 RPAREN Stmt:s3 ELSE Stmt:s4 			{: RESULT = s2 + ".endsWith(" + s1 + ")?" + s3 + ":" + s4; :}
				; 

ID 				::=	STRING_LITERAL:s 				{: RESULT = s; :}
				;