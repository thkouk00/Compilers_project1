/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;


/**
 *  Usercode Components
 */

action code {:
	int FnCflag=0;
	int CompoundFlag = 0;
:}

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, TIMES, LPAREN, RPAREN, LBRAC, RBRAC, COMMA, QUOT;
terminal String     STRING_LITERAL, QSTR;        // our scanner provides numbers as strings

/*  Non terminals */
/*
non terminal            expr_list;
non terminal String    expr;      // used to store evaluated subexpressions
*/

/*  Non terminals */
non terminal            Goal, Start, Function, FunctionD, FunctionC,FDecl, FCall, CompoundStmt, CompoundStmtD;
non terminal String    Declaration, DeclarationD, DeclarationC, Concatenation, ConcatenationD, StringContent, Temp;      // used to store evaluated subexpressions




/**
 *  Precedence Declarations
 */

precedence left PLUS, MINUS;
precedence left TIMES;

/**
 *  The Grammar Rules
 */

/* kanonas gia func Decl kai meta kanonas gia func calls , opote otan einai gia func calls sthn arxh ftiaxnw thn main */

/* take all inputs such as : first function declarations and after function calls or vice versa */

/* xreaizetai kai ena Goal ::= Start; gia na ftiaxoyme thn Main class */

Goal	::=
		Start:s 					{:System.out.println("public class Main {\n\t" + s + "\n}");:}
		;

Start ::=	FunctionD:s1 FunctionC:s2			{:System.out.println("PER 1");  RESULT = "\n\tpublic static void main(String[] args){\n\t" + s2 + "\t}\n\n\t" + s1; :}
		|	FunctionC FunctionD					{:System.out.println("PER 2");:}
		|	FunctionD							{:System.out.println("PER 3");:}
		|	FunctionC:s							{:System.out.println("PER 4"+ s);:}
		;		



FunctionD	::=	FunctionD:s1 STRING_LITERAL:s2 LPAREN RPAREN CompoundStmt:s3 									{: if (FnCflag == 0) RESULT = s1 + "public static String " + s2 + "()" + s3 + "\n\t";
																													else throw new Error("Error!"); :}
			|	FunctionD:s1 STRING_LITERAL:s2 LPAREN DeclarationD:s3 RPAREN CompoundStmtD:s4					{: if (FnCflag == 0) RESULT = s1 + "public static String " + s2 + "(" + s3 + ")" + s4 ;
																													else throw new Error("Error!"); :}
			|	STRING_LITERAL:s1 LPAREN RPAREN CompoundStmt:s2 												{: if (FnCflag == 0) RESULT = "public static String " + s1 + "()" + s2 + "\n\t" ;
																													else throw new Error("Error!");  :}
			|	STRING_LITERAL:s1 LPAREN DeclarationD:s2 RPAREN CompoundStmtD:s3 								{:  if (FnCflag == 0) RESULT = "public static String " + s1 + "(" + s2 + ")" + s3 + "\n\t";
																													else throw new Error("Error!"); :}
			; 

FunctionC	::=	FunctionC:s1 STRING_LITERAL:s2 LPAREN RPAREN									{:  RESULT = s1 + "\t\tSystem.out.println(" + s2 +"());\n"; :}
			|	FunctionC:s1 STRING_LITERAL:s2 LPAREN DeclarationD:s3 RPAREN 					{:  RESULT = s1 + "\t\tSystem.out.println(" + s2 +"(" + s3 + "));\n";:}
			|	STRING_LITERAL:s LPAREN RPAREN 													{:  RESULT = "\tSystem.out.println(" + s + "());\n"; :}
			|	STRING_LITERAL:s1 LPAREN DeclarationD:s2 RPAREN 								{:  System.out.println("flag is "+FnCflag +""+s);RESULT = "\tSystem.out.println(" + s1 + "(" 																							+ s2 + "));"  ; :}
			;

FDecl		::=	RPAREN CompoundStmt 					/* prevent function with no args to return variable */
			|	DeclarationD RPAREN CompoundStmtD 		/* function with args can return arg */
			;

FCall		::=	RPAREN 
			|	DeclarationC RPAREN
			
			;

CompoundStmt	::=	LBRAC QSTR:s RBRAC 					{: CompoundFlag = 1; System.out.println("HERE "+ s); RESULT = "{\n\t\treturn \"" + s + "\";\n\t}"; :}   
    			;

CompoundStmtD	::=	LBRAC ConcatenationD:s RBRAC 					{: CompoundFlag = 1; System.out.println("HERE# "+ s); RESULT = "{\n\t\treturn " + s + ";\n\t}"; :}   
    			;

Declaration 	::=	 
					Concatenation COMMA Declaration
				|	STRING_LITERAL COMMA Declaration
				|	Concatenation
				;

DeclarationD 	::= DeclarationD:s1 COMMA STRING_LITERAL:s2 				{: 
																				 RESULT = s1 + ", String " + s2; :}
				|	DeclarationD:s1 COMMA Concatenation:s2 					{: RESULT = s1 + "," + s2;:}
				|	STRING_LITERAL:s 										{: 
																					RESULT = "String " + s;  :}
				|	Concatenation:s 										{: FnCflag = 1; 
																					{System.out.println("EDW "+s);RESULT = s;System.out.println(s);} :}
				;						


DeclarationC 	::= DeclarationC:s1 COMMA STRING_LITERAL:s2  				{: RESULT =  s1 + "," + s2 ;:}
				|	DeclarationC:s1 COMMA Concatenation:s2 					{: RESULT =  s1 + "," + s2 ;:}
				|	Concatenation:s 										{: RESULT = s; :}
				;

Concatenation	::=	QSTR:s 										{: System.out.println("ALA"+s+" flag "+FnCflag); RESULT = "\"" + s + "\""; System.out.println(RESULT);:}
				/*QUOT StringContent:s QUOT 					{: System.out.println("ALA"+s+" flag "+FnCflag); RESULT = "\"" + s + "\""; System.out.println(RESULT);:}
				| 	QUOT QUOT 			{:RESULT = "\" \"";:} */
				; 

ConcatenationD	::=	ConcatenationD:s1 PLUS STRING_LITERAL:s2	{: RESULT = s1 + " + " + s2; :}
				|	QSTR:s 					{: System.out.println("ALA"); RESULT = "\"" + s + "\""; :}
				|	STRING_LITERAL:s 							{: RESULT = s; :}
				;

StringContent 	::=	StringContent:s1 STRING_LITERAL:s2 			{: RESULT = s1 + " " + s2; :}
				|	STRING_LITERAL:s 							{: System.out.println("EINAI "+s + ".");RESULT = s; :}
				;



/*
expr_list ::=	expr_list expr:e SEMI       {: System.out.print("Rule 1 "); System.out.println(e);         :} 
			|	expr:e SEMI					{: System.out.print("Rule 2 "); System.out.println(e);         :}
			|	expr:e 						{: System.out.print("Rule 3 "); System.out.println(e);         :}
			|	expr:e LPAREN RPAREN		{: System.out.print("Rule 4 "); System.out.println(e);         :}
			;
expr 	::= STRING_LITERAL:s	            {: System.out.print("**** ");RESULT = s;  :}
		| 	expr:y LPAREN expr:e RPAREN	        {: RESULT = y+e;  :}
		;
*/


/*
expr_list ::= expr_list expr:e SEMI         {: System.out.println("Rule 1"); System.out.println(e);         :}
            | expr:e SEMI                   {: System.out.println("Rule 2"); System.out.println(e);         :}
;
expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;                :}
             | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;                :}
             | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;                :}
             | LPAREN expr:e RPAREN	        {: RESULT = e;                    :}
             | STRING_LITERAL:s	            {: RESULT = Integer.parseInt(s);  :}
             ;
*/